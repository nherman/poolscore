{% extends "master.html" %}
{% set body_class = "root-context" %}

{% block script %}
<script type="text/javascript">
/* TODO?
    Create local models for each entity: tourney, match, player, game

    Populate local models with entities or collections of entities

    bind each entity/collection to a section of markup?

    posible models:
        tourney
        match (matches?)
        game (games?)
        player (players?)
        newMatch viewmodel

*/

function NewTourneyModel() {
    var self = this,
    userId = "{{session.user_id}}",
    tourney_id = "{{ tourney_id }}",
    initTemplateOptions = {
        "name": ""
    },
    mainBlockTemplateOptions = {
        "name": "match_list_template",
        "data": self
    },
    api = (function() {
        var ep, root = "/api/v1.0/";

        function _m(n,p) {
            return {"path":root + p,"node": n};
        }

        function _p(endpoint) {
            var i=1, p;
            if (ep[endpoint] === undefined) return "";
            p = ep[endpoint].path;

            while(i < arguments.length) {
                p = p.replace(/%s/,arguments[i++]);
            }

            return p;
        }

        function _n(endpoint) {
            if (ep[endpoint] !== undefined) {
                return ep[endpoint].node;
            }
            return "";
        }

        ep = {
            "tourney": _m("tourney", "tourneys/%s.json"),
            "matches": _m("matches", "tourneys/%s/matches.json"),
            "newmatch": _m("match", "tourneys/%s/matches.json")
        };

        return {
            "node": _n,
            "path": _p,
            "get": function(endpoint, args, callback) {
                var url, node;
                if (typeof callback !== "function" || !Array.isArray(args)) return;

                args.unshift(endpoint);

                url = _p.apply(this, args);
                node = _n(endpoint);

                $.getJSON( url, function( json ) {
                    if (json[node] !== undefined) {
                        callback(json[node]);
                    }
                });
            }
        };
    })();

    function _isEmpty(v) { return (v == undefined || v == null || v == "");}

    function _initTourney(json) {
        var date, time, t;
        self.tourney(json);
        if (self.tourney() === undefined) return;

        //date
        date = new Date(self.tourney().date);
        self.tourneyDate(date.toDateString());

        //start time
        if (self.tourney().events != null) {
            events = ko.utils.parseJson(self.tourney().events);
            if (events.start_time != null) {                
                self.tourneyStartTime(events.start_time);
            }
        }

        //init player options
        self.addMatch.populate();
    }


    self.mainBlockTemplateOptions = ko.observable(initTemplateOptions);
    self.tourney = ko.observable();
    self.tourneyDate = ko.observable();
    self.tourneyStartTime = ko.observable();
    self.matches = ko.observableArray();
    self.addMatch = (function() {
        var options = {};

        function _getPlayerId(o) {
            a = o.split('_');
            return {
                "team": a[0],
                "id": a[1]
            }
        }

        function _getPlayerSelectItem(p, team) {
            return {
                "value":team + "_" + p.id,
                "label":p.last_name + ", " + p.first_name + " (" + p.handicap + ")",
                "team": team
            };
        }

        options.home = [];
        options.away = [];

        return {
            getplayer: _getPlayerId,
            lag_winner: ko.observable(),
            lag_loser: ko.observable(),
            options: options,
            canAdd: function() { return false; },
            populate: function() {
                if (self.tourney() != undefined) {
                    self.tourney().home_team.players.forEach(function(p) {
                        self.addMatch.options.home.push(_getPlayerSelectItem(p, 'home'));
                    });
                    self.tourney().away_team.players.forEach(function(p) {
                        self.addMatch.options.away.push(_getPlayerSelectItem(p, 'away'));
                    });
                }
            },
            add: function() {
                var url, data = {
                    "match":{
                        "events": {
                            "lag": null
                        }
                    },
                    "home_players": [],
                    "away_players": [],
                };

                function _populateData(p,w) {
                    var o = _getPlayerId(p);
                    data[o.team + '_players'].push(o.id);
                    if (w) {
                        data.match.events.lag = o.team;
                    }
                }

                if (!this.canAdd()) return;

                _populateData(this.lag_winner(),true);
                _populateData(this.lag_loser(),false);


                url = api.path("newmatch", self.tourney().id);

                $.ajax(url, {
                    data: ko.toJSON(data),
                    type: "POST",
                    contentType: "application/json",
                    error: function(jqXHR, textStatus, errorThrown) {
                        var message = errorThrown;
                        if ( jqXHR.responseJSON && jqXHR.responseJSON.message ) {
                            message = jqXHR.responseJSON.message;
                        }
                        console.log(textStatus + ': ' + message + ' - Unable to save');
                        // window.PS.alertsModel.add({
                        //     'content': textStatus + ': ' + message + ' - Unable to save',
                        //     'type':'error'
                        // });
                    },
                    success: function(data) {
                        console.log(data);
                        self.matches.push(data);
                    }
                });

            }
        };
    })();
    self.addMatch.canAdd =  ko.computed(function() {
        var wid, lid;
        if (_isEmpty(this.lag_winner()) || _isEmpty(this.lag_loser())) {
            return false;
        }
        wid = this.getplayer(this.lag_winner());
        lid = this.getplayer(this.lag_loser());
        if(wid.id == lid.id) return false;
        return true;
    }, self.addMatch)
    self.utils = (function(match) {
        var id_len = 5,
            handicap_matrix = [
                [2,2,2,2,2,2],
                [3,2,2,2,2,2],
                [4,3,3,3,3,2],
                [5,4,4,4,4,3],
                [6,5,5,5,5,4],
                [7,6,5,6,5,5],
            ];

        function _getLag(match, isLagger) {
            var players, team, r = {
                "player":undefined,
                "team":undefined,
                "games_needed":undefined
            };
            if (match !== undefined && match.events !== undefined && match.events.lag !== undefined) {

                if ((isLagger && match.events.lag == "home") ||
                    (!isLagger && match.events.lag == "away")) {
                        players = match.home_players;
                        opponents = match.away_players;
                        r.team = "home";
                } else {
                        players = match.away_players;
                        opponents = match.home_players;
                        r.team = "away";            
                }


                if (Array.isArray(players)) {
                    r.player = players[0];
                    if (Array.isArray(opponents)) {
                        p = r.player.handicap;
                        o = opponents[0].handicap;
                        r.games_needed = handicap_matrix[p-2][o-2];
                    }
                }

            }

            return r;
        }

        function _padID(id, n) {
            var p = id + "",
                d = n - p.length;
            while (d>0) {
                p = "0" + p;
                d--;
            }
            return p;
        }

        function _incEvent(obj, eventName, input) {
            try {
                if (Number.isInteger(game.events[eventName])) {
                    game.events[eventName] += input;
                } else {
                    game.events[eventName] = input;
                }


            } catch(e) {
                console.log(e);
            }
        }

        return {
            getLagLosePlayer:function(match) {
                return _getLag(match, false).player;
            },
            getLagWinPlayer:function(match) {
                return _getLag(match, true).player;
            },
            getLagWinTeam:function(match) {
                return _getLag(match, true).team;
            },
            getLagLoseTeam:function(match) {
                return _getLag(match, false).team;
            },
            getLagWinGames:function(match) {
                return _getLag(match, true).games_needed;
            },
            getLagLoseGames:function(match) {
                return _getLag(match, false).games_needed;
            },
            padID: function(id, n) {
                if (!Number.isInteger(n)) n = id_len;
                return _padID(id, n);
            },
            getActiveGame: function(match) {
                if (match.games.length) {
                    game = match.games[match.games.length-1];
                }
                if (!Number.isInteger(game.winner_id)) return undefined;

                return game;
            },
            eventIncrement: function(game, eventName) {
                _incEvent(game, eventName, 1);
            },
            eventDecrement: function(game, eventName) {
                _incEvent(game, eventName, -1);
            }
        };
    })();


    /* initialize model data */
    api.get("tourney", [tourney_id], function(json) {
        _initTourney(json);
        self.mainBlockTemplateOptions(mainBlockTemplateOptions)
    })

    api.get("matches", [tourney_id], function(json) {
        console.log(json);
        self.matches(json);
        // for (var i=0;i<json.length;i++) {
        //     console.log(json[i]);
        //     json[i].games = ko.observableArray(json[i].games);
        //     self.matches.push(json[i])
        // }
        // console.log(self.matches());

        /* TODO: 
            Write method that uses ko.mapping to de-serialize each individual match. Use it to init each match in this method AND each time a match is added via addMatch

            Use mapping configuration to only make necessary objects observable:
            var map_config = {
                "observe": ['games', 'events', 'winner_id']
            };

            Add new attributes to make things easier (?):
                lag_winner = player object
                lag_loser = player object
                lag_winner.games_needed
                lag_loser.games_needed

            Use mapping configuration to make sure these new attributes are ignored on serialization:
            var map_config = {
                "ignore": ['lag_winner','lag_loser']
            };

            example mapping calls (for new and existing models):
            var match = ko.mapping.fromJS(data, map_config);
            ko.mapping.fromJS(data, map_config, match)

        */
    });

}

//ko.applyBindings(new NewTourneyModel(), document.getElementById('main'));

</script>
<script type="text/javascript">
function addMatchViewModel(options) {
    var self = this,
        options = ko.utils.extend({
            "tourney_id": undefined,
            "home_players": [],
            "away_players": [],
            "onAdd": function() {}
        }, options);

    function _isEmpty(v) { return (v == undefined || v == null || v == "" || v == -1);}

    function _getPlayerId(o) {
        a = o.split('_');
        return {
            "team": a[0],
            "id": a[1]
        }
    }

    function _getPlayerSelectItem(p, team) {
        return {
            "value":team + "_" + p.id,
            "label":p.last_name + ", " + p.first_name + " (" + p.handicap + ")",
            "team": team
        };
    }

    self.selectItems = {
        "home": [],
        "away": []
    };

    self.lag_winner = ko.observable();
    self.lag_loser = ko.observable();

    self.resetForm = function() {
        self.lag_winner(-1);
        self.lag_loser(-1);
    };

    self.canAdd = ko.computed(function() {
        var wid, lid;
        if (_isEmpty(self.lag_winner()) || _isEmpty(self.lag_loser())) {
            return false;
        }
        wid = _getPlayerId(this.lag_winner());
        lid = _getPlayerId(this.lag_loser());
        if(wid.id == lid.id || wid.team == lid.team) return false;
        return true;
    }, self)

    self.init = function(initOptions) {
        initOptions = initOptions || {};
        options = ko.utils.extend(options, initOptions);

        ko.utils.arrayForEach(options.home_players, function(p) {
            self.selectItems.home.push(_getPlayerSelectItem(p, 'home'));
        });
        ko.utils.arrayForEach(options.away_players, function(p) {
            self.selectItems.away.push(_getPlayerSelectItem(p, 'away'));
        });
    }

    self.add = function() {
        var data = {
                "match":{
                    "events": {
                        "lag": null
                    }
                },
                "home_players": [],
                "away_players": []
            };

        function _populateData(p,w) {
            var o = _getPlayerId(p);
            data[o.team + '_players'].push(o.id);
            if (w) {
                data.match.events.lag = o.team;
            }
        }

        if (!self.canAdd()) return;

        _populateData(this.lag_winner(),true);
        _populateData(this.lag_loser(),false);


        PS.API.createMatch(options.tourney_id, data,
            function(json) {
                self.resetForm();
                options.onAdd(json);
            }
        );
    };

}

function ViewModel() {
    var self = this,
        tourney_id = "{{ tourney_id }}",
        matches_endpoint,
        initTemplateOptions = {
            "name": ""
        },
        headerTemplateOptions = {
            "name": "header_template",
            "data": {}
        },
        matchTemplateOptions = {
            "name": "match_template",
            "data": {}
        };


    /* initialize templates */
    self.headerTemplateOptions = ko.observable(initTemplateOptions);
    self.matchTemplateOptions = ko.observable(initTemplateOptions);

    /* Render Add Match Form */
    self.addMatchViewModel = new addMatchViewModel({
        "tourney_id": tourney_id,
        "onAdd": function(resp) {
            matchJSON = resp.match || resp;
            if (typeof matchJSON == "object" && matchJSON.id !== undefined) {
                self.matches.push(new Match(matchJSON.id, {
                    "json": matchJSON,
                    "tourney": self
                }));
            }
        }
    });


    /* populate Tourney model */
    self.tourney = new Tourney(tourney_id, {

        /* Tourney onInit callback */
        "callback": function() {

            /* update add match form to include available players */
            self.addMatchViewModel.init({
                "home_players": self.tourney.home_team.players,
                "away_players": self.tourney.away_team.players
            });

            /* render templates */
            headerTemplateOptions.data = self.tourney;
            self.headerTemplateOptions(headerTemplateOptions);

            matchTemplateOptions.data = self;
            self.matchTemplateOptions(matchTemplateOptions);
        }
    });

    /* get all Matches */
    self.matches = ko.observableArray();

    PS.API.getMatches(tourney_id,
        function(json) {
            if (json === undefined || typeof json != "object") return;

            ko.utils.arrayForEach(json["matches"], function(match){
                self.matches.push(new Match(tourney_id, match.id, {
                    "json": match,
                    "tourney": self
                }));
            });
        }
    );


}

window.PS.API = (function() {
    var root = "/api/v1.0/";

    function _p(path) {
        var i=1;
        if (path === undefined) return "";

        while(i < arguments.length) {
            path = path.replace(/%s/,arguments[i++]);
        }

        return root + path;
    }

    function _run(method, url, payload, callback) {
        var settings = {
                type: method,
                url: url,
                data: payload,
                dataType: "json"
            };

        if (method == undefined || url == undefined) return;

        if (typeof payload == 'object') {
            if ($.isEmptyObject(payload)) {
                settings.data = '';
            } else {
                settings.data = JSON.stringify(payload);
            }
        } else {
            settings.data = payload;
        }

        if (typeof callback == "function") {
            settings.success = callback;
        }

        return $.ajax(settings);
    }

    function _get(url, callback) {
        return _run("GET", url, "", callback)
    }

    function _put(url, payload, callback) {
        return _run("PUT", url, payload, callback)
    }

    function _post(url, payload, callback) {
        return _run("POST", url, payload, callback)
    }

    function _delete(url, callback) {
        return _run("DELETE", url, "", callback)
    }

    return {
        getTourney: function(id, callback) {
            var url = _p("tourneys/%s.json", id);
            return _get(url, callback);
        },

        updateTourney: function(id, data, callback) {
            var url = _p("tourneys/%s.json", id);
            return _put(url, data, callback);
        },

        getMatches: function(tourney_id, callback) {
            var url = _p("tourneys/%s/matches.json", tourney_id);
            return _get(url, callback);
        },

        createMatch: function(tourney_id, data, callback) {
            var url = _p("tourneys/%s/matches.json", tourney_id);
            return _post(url, data, callback);
        },

        getMatch: function(tourney_id, match_id, callback) {
            var url = _p("tourneys/%s/matches/%s.json", tourney_id, match_id);
            return _get(url, callback);
        },

        updateMatch: function(id, data, callback) {
            var url = _p("tourneys/%s.json", id);
            return _put(url, data, callback);
        },
/*
        getGames: function(match_id, callback) {
            var url = _p("tourneys/%s/matches.json", match_id);
            return _get(url, callback);
        },

        createGame: function(tourney_id, data, callback) {
            var url = _p("tourneys/%s/matches.json", tourney_id);
            return _post(url, data, callback);
        },

        getGame: function(id, callback) {
            var url = _p("tourneys/%s.json", id);
            return _get(url, callback);
        },

        updateGame: function(id, data, callback) {
            var url = _p("tourneys/%s.json", id);
            return _put(url, data, callback);
        }
*/
    };

})();

window.PS.utils = (function() {
    return {
        isEmpty: function(v) {
            return (v == undefined || v == null || v == "");
        }
    };
})();

/* Parent class for Tourney, Match & Game */
function Entity(id, config) {
    var self = this,
        config = ko.utils.extend({
            "callback": function() {},
            "map_config": {}
        }, config),
        _map_config = {
            'ignore': ['configuration', 'id'],
            'observe': ['data','events'],
            'events': {
                create: function(options) {
                    var events = options.data
                    if(typeof events === "string") {
                        events = ko.utils.parseJson(events);
                    }
                    return ko.observable(ko.mapping.fromJS(events));
                }
            }
        };

    /* merge config.map_config with _map_config and copy merged object to config.map_config */
    for (key in config.map_config) {
        if (config.map_config.hasOwnProperty(key)) {
            if (config.map_config[key] instanceof Array) {
                _map_config[key] = _map_config[key].concat(config.map_config[key]);
            } else {
                _map_config[key] = config.map_config[key];                
            }
        }
    }

    self.id = id;
    self.configuration = config;
    self.configuration.map_config = _map_config;

    self.onBeforeMap();

    /* initialize model data */
    if (typeof self.configuration.json == "object") {
        self.map(self.configuration.json);
        self.onAfterMap(self.configuration.json);
        self.configuration.callback();
    } else {
        self.get(function(json) {
            self.onAfterMap(json);
            self.configuration.callback();
        });
    }
}

Entity.prototype.onBeforeMap = function() {};
Entity.prototype.onAfterMap = function() {};

Entity.prototype.map = function(json) {
    ko.mapping.fromJS(json, this.configuration.map_config, this);
};

Entity.prototype.get = function() {
    throw "get method not defined";
};

Entity.prototype.update = function() {
    throw "update method not defined";
};


function Tourney(id, options) {
    var self = this,
        options = ko.utils.extend({
            "map_config": {
                'ignore': ['tourneyDate'],
                'observe': ['date','winner_id','home_score','away_score'],
                'date': {
                    create: function(options) {
                        self.tourneyDate = ko.computed(function() {
                            /* hack to disregard time zone. Needs to be fixed - probably in the data model */
                            var date = new Date(self.date());
                            var date2 = new Date(date.getTime() + date.getTimezoneOffset()*60*1000);
                            return date2.toDateString();
                        });                    
                        return ko.observable(options.data);
                    }
                }
            }
        }, options);

    Entity.call(self, id, options);
}
Tourney.prototype = Object.create(Entity.prototype);

Tourney.prototype.get = function(callback) {
    var self = this;
    PS.API.getTourney(self.id, function(json) {
        self.map(json["tourney"]);
        if (typeof callback == "function") {
            callback.call(self);
        }
    });
};

Tourney.prototype.update = function(callback) {
    var self = this,
        data = {};

    /* wrap data in entity name node and remove extraneous objects */
    data["tourney"] = ko.mapping.toJS(self);
    delete data["tourney"].home_team;
    delete data["tourney"].away_team;

    PS.API.updateTourney(self.id, data, function(json) {
        if (typeof callback == "function") {
            callback.call(self);
        }
    });
};

function Match(tourney_id, id, options) {
    var self = this,
        options = ko.utils.extend({
            "map_config": {
                'ignore': ['tourney_id', 'lag_winner', 'lag_loser', 'in_progress', 'games'],
                'observe': ['home_score','home_games_won','away_score','away_games_won','winner_id']
            }
        }, options);

    self.tourney_id = tourney_id;
    self.in_progress = ko.observable();
    self.lag_winner = ko.observable();
    self.lag_loser = ko.observable()
    self.games = ko.observableArray();

    Entity.call(self, id, options);

}
Match.prototype = Object.create(Entity.prototype);

Match.prototype.onAfterMap = function(json) {
    var self = this;

    /* populate games array */
    ko.utils.arrayForEach(json["games"], function(game){
        self.games.push(new Game(self.tourney_id, self.id, game.id, {
            "json": game
        }));
    });

    /* initialize lag winner/loser */
    lag_team = self.events().lag();
    no_lag_team = (lag_team == "home") ? "away" : "home";
    self.lag_winner(self[lag_team + "_players"][0]);
    self.lag_loser(self[no_lag_team + "_players"][0]);

    self.in_progress(window.PS.utils.isEmpty(self.winner_id()))
};

Match.prototype.get = function(callback) {
    var self = this;

    PS.API.getMatch(self.tourney_id, self.id,
        function(json) {
            self.map(json["match"]);
            if (typeof callback == "function") {
                callback.call(self);
            }
        }
    );
};

Match.prototype.update = function(callback) {
    var self = this,
        data = {};

    data["match"] = ko.mapping.toJS(self);

    PS.API.updateMatch(self.tourney_id, self.id, data,
        function(json) {
            if (typeof callback == "function") {
                callback.call(self);
            }
        }
    );
};

function Game(tourney_id, match_id, id, options) {
    var self = this,
        options = ko.utils.extend({
            "map_config": {
                'ignore': ['tourney_id', 'match_id','in_progress'],
                'observe': ['winner_id']
            }
        }, options);

    self.tourney_id = tourney_id;
    self.match_id = match_id;
    self.in_progress = ko.observable();

    Entity.call(self, id, options);
}
Game.prototype = Object.create(Entity.prototype);


Game.prototype.onAfterMap = function(json) {
    var self = this;
    self.in_progress(window.PS.utils.isEmpty(self.winner_id()))
};

Game.prototype.get = function(callback) {
    var self = this;

    PS.API.getGame(self.tourney_id, self.match_id, self.id,
        function(json) {
            self.map(json["game"]);
            if (typeof callback == "function") {
                callback.call(self);
            }
        }
    );
};

Game.prototype.update = function(callback) {
    var self = this,
        data = {};

    data["game"] = ko.mapping.toJS(self);

    PS.API.updateGame(self.tourney_id, self.match_id, self.id, data,
        function(json) {
            if (typeof callback == "function") {
                callback.call(self);
            }
        }
    );
};


//ko.applyBindings(new Tourney("{{ tourney_id }}"), document.getElementById('tourney'));
ko.applyBindings(new ViewModel(), document.getElementById('main'));
</script>
{% endblock %}

{% block body %}
    <!-- ko template: headerTemplateOptions --><!-- /ko -->
    <!-- ko template: matchTemplateOptions --><!-- /ko -->


<script type="text/html" id="header_template">
    <div id="tourney">
        <h6 class="text-center"><span data-bind="text: tourneyDate()"></span> <span data-bind="text: events().start_time()"></span></h6>
        <h3 class="text-center"><span data-bind="text: home_team.name"></span> <small>(Home)</small><br/><small>vs.</small><br/><span data-bind="text: away_team.name"></span> <small>(Away)</small></h3>
    </div>
</script>

<script type="text/html" id="match_template">
    <table class="match_list">
        <thead>
            <tr>
                <th>Player Name</th>
                <th class="rotate">Games<br>Needed</th>
                <th class="rotate">Games<br>Won</th>
                <th class="rotate">Match<br>Points</th>
            </tr>
        </thead>
        <tbody>

        <!-- ko foreach: {data: matches, as: 'match'} -->
            <tr data-bind=" css: {'active_pulse': match.in_progress()},
                            template: {
                                name: 'display_player_template', data: {
                                    match: match,
                                    player: match.lag_winner(),
                                    team: match.events().lag()
                                },
                                if: match.lag_winner()
                            } ">
            </tr>
            <tr data-bind=" css: {'active_pulse': match.in_progress()},
                            template: {
                                name: 'display_player_template',
                                data: {
                                    match: match,
                                    player: match.lag_loser(),
                                    team: (match.events().lag() == 'home') ? 'away' : 'home'
                                },
                                if: match.lag_loser()
                            } ">
            </tr>
            <!-- ko if: match.in_progress() == true -->
            <tr>
                <td colspan="4">
                    <div data-bind="foreach: {data: games, as: 'game'}">
                        <div style="border:1px solid #fafafa;" data-bind="text: game">
            <!--
                            <span>#<span data-bind="text: game.ordinal"></span></span>
                            <span>Innings: <span data-bind="text: game.events.innings"></span></span>
                            <span>home coach: <span data-bind="text: game.events.home_coaches"></span></span>
                            <span>away coach: <span data-bind="text: game.events.away_coaches"></span></span>
                            <span>home safe: <span data-bind="text: game.events.home_safes"></span></span>
                            <span>away safe: <span data-bind="text: game.events.away_safes"></span></span>
                            <span>winning team: <span data-bind="text: game.winner_id"></span></span>
            -->
                        </div>
                    </div>
                </td>
            </tr>
            <!--
            <tr>
                <td colspan="4" data-bind="with: $root.utils.getActiveGame(match)">
                    <p>Edit Game #<span data-bind="text: ordinal"></span></p>
                    <button class="btn btn-default" data-bind="click: $root.utils.eventIncrement($data,'innings')">+</button>

                </td>
            </tr>
            -->
            <!-- /ko -->
        <!-- /ko -->

        <!-- ko with: addMatchViewModel -->
            <tr class="top-row">
                <td data-bind="template: { name: 'select_player_template', data: {
                    options:selectItems,
                    value:lag_winner,
                    placeholder: 'Select Lag Winner'
                }}"></td>
                <td colspan="4" rowspan="2" class="text-center" style="vertical-align: middle;" data-bind="if: canAdd"><button class="btn btn-default" data-bind="click: add, text: 'Start Match'">Start Match</button></td>
            </tr>
            <tr class="bottom-row">
                <td data-bind="value: lag_loser , template: { name: 'select_player_template', data: {
                    options:selectItems,
                    value:lag_loser,
                    placeholder: 'Select Lag Loser'
                }}"></td>
            </tr>
        <!-- /ko -->

        </tbody>
    </table>
</script>

<script type="text/html" id="display_player_template">
    <td>
        <span style="font-weight:bold;" data-bind="text: (team == 'home') ? 'H' : 'A'"></span>&nbsp;
        <span data-bind="text: player.first_name"></span>
        <span data-bind="text: player.last_name"></span>
        (<span data-bind="text: player.handicap"></span>)
        <a data-bind="attr: {href: '/team/player/' + player.id}, text: player.player_id" href="#"></a>
    </td>
    <td data-bind="text: match[team+'_games_needed']"></td>
    <td data-bind="text: match[team+'_games_won']"></td>
    <td data-bind="text: match[team+'_score']"></td>
</script>


<script type="text/html" id="select_player_template">
    <select required placeholder="Select a Player" data-bind="value: value">
        <option default selected="selected" data-bind="text: placeholder, value: -1">Select a Player</option>
        <optgroup label="Home Team" data-bind="foreach: options.home">
            <option data-bind="text: label, value: value" ></option>
        </optgroup>
        <optgroup label="Away Team" data-bind="foreach: options.away">
            <option data-bind="text: label, value: value" ></option>
        </optgroup>
        <option value="0">FORFEIT</option>
    </select>
</script>


{% endblock %}
